#N canvas 383 49 1545 616 12;
#X msg 146 108 bang;
#X text 45 32 You can generate weighted random numbers from uniformly distributed ones. If you just want two possible outcomes with a varying probability for each one \, you can do as shown:;
#X obj 146 137 random 100;
#X obj 145 223 bng 20 250 50 0 empty empty empty 0 -6 0 8 #fcfcfc #000000 #000000;
#X obj 199 223 bng 20 250 50 0 empty empty empty 0 -6 0 8 #fcfcfc #000000 #000000;
#X floatatom 199 166 3 0 100 0 - - - 0;
#X obj 146 195 moses 80;
#X text 53 262 This outputs a number at left 80% of the time \, otherwise at right \, unless you override the "80" using the number box. You may extend this to more than two possible outcomes \, for instance like this:, f 56;
#X msg 103 351 bang;
#X obj 103 377 random 100;
#X obj 102 434 bng 20 250 50 0 empty empty empty 0 -6 0 8 #fcfcfc #000000 #000000;
#X obj 193 434 bng 20 250 50 0 empty empty empty 0 -6 0 8 #fcfcfc #000000 #000000;
#X obj 103 405 moses 10;
#X obj 193 405 moses 30;
#X obj 246 434 bng 20 250 50 0 empty empty empty 0 -6 0 8 #fcfcfc #000000 #000000;
#X text 100 459 10%;
#X text 191 459 20%;
#X text 248 459 70%;
#X text 231 166 <= change probability;
#X text 187 106 <= click to test;
#X text 143 349 <= click to test;
#X obj 497 133 tgl 15 0 empty empty empty 17 7 0 10 #fcfcfc #000000 #000000 0 1;
#N canvas 0 22 450 278 (subpatch) 0;
#X array markov1 6 float 3;
#A 0 0.1 0.280899 0.466292 0.483146 0.359551 0.202247;
#X coords 0 1 6 0 266 178 1 0 0;
#X restore 932 143 graph;
#X obj 693 199 s markov1;
#X text 537 265 lowest note;
#X msg 497 466 \$1 100;
#N canvas 0 22 450 278 (subpatch) 0;
#X array scale 7 float 3;
#A 0 0 2 4 6 8 10 12;
#X coords 0 12 7 0 200 140 1 0 0;
#X restore 1236 124 graph;
#X obj 497 233 tabread scale;
#X msg 1238 278 \; scale resize 7 \; scale 0 0 2 4 6 8 10 12;
#X floatatom 508 203 5 0 0 0 - - - 0;
#X text 879 55 these are the weights for each scale degree \, you don't need to scale them \, since the object will do automatically. They are visualised in the markov1 table.;
#X msg 709 90 0 0.2 0.5 0.7 1 0.1 0.3;
#X msg 719 118 0.1 0.4 0.5 0 0 0.1;
#X obj 630 526 bendout, f 16;
#X obj 630 389 * 4096;
#X obj 630 364 wrap;
#X obj 686 389 bendin, f 8;
#X obj 686 414 - 8192;
#X obj 630 479 + 0;
#X obj 686 439 t b f;
#X obj 630 502 change;
#X obj 497 523 noteout 1;
#X obj 497 152 metro 400;
#X obj 497 492 makenote 100 350;
#X text 755 383 Be aware that this method of non-tempered tuning will work in monodic (sequential) signals... For polyphony or chords \, we would need a slightly more complicated strategy (i.e. creating separate voices in separate midi channels;
#X obj 497 178 array random markov1;
#X floatatom 557 127 5 0 0 0 - - - 0;
#X obj 693 175 list prepend 0;
#X floatatom 802 201 5 0 0 0 - - - 0;
#X msg 802 228 \; markov1 resize \$1;
#X obj 693 149 t l l, f 16;
#X obj 802 176 list length;
#X msg 693 62 0 1 0 0 0 0 0.5;
#X obj 497 263 + 60;
#X msg 1239 344 \; scale resize 7 \; scale 0 0 2 3 5 7 8 10 12;
#X msg 673 32 1 0.2 0.5 0.2 0.6 0.2 0.2;
#X connect 0 0 2 0;
#X connect 2 0 6 0;
#X connect 5 0 6 1;
#X connect 6 0 3 0;
#X connect 6 1 4 0;
#X connect 8 0 9 0;
#X connect 9 0 12 0;
#X connect 12 0 10 0;
#X connect 12 1 13 0;
#X connect 13 0 11 0;
#X connect 13 1 14 0;
#X connect 21 0 42 0;
#X connect 25 0 43 0;
#X connect 27 0 53 0;
#X connect 31 0 50 0;
#X connect 32 0 50 0;
#X connect 34 0 38 0;
#X connect 35 0 34 0;
#X connect 36 0 37 0;
#X connect 36 1 33 1;
#X connect 37 0 39 0;
#X connect 38 0 40 0;
#X connect 39 0 38 0;
#X connect 39 1 38 1;
#X connect 40 0 33 0;
#X connect 42 0 45 0;
#X connect 43 0 41 0;
#X connect 43 1 41 1;
#X connect 45 0 27 0;
#X connect 45 0 29 0;
#X connect 46 0 42 1;
#X connect 47 0 23 0;
#X connect 48 0 49 0;
#X connect 50 0 47 0;
#X connect 50 1 51 0;
#X connect 51 0 48 0;
#X connect 52 0 50 0;
#X connect 53 0 25 0;
#X connect 53 0 35 0;
#X connect 55 0 50 0;
